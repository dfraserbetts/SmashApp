import { buildDescriptorResult } from "@/lib/descriptors/descriptorEngine";
import { renderForgeResult } from "@/lib/descriptors/renderers/forgeRenderer";
import type {
  MonsterNaturalAttackConfig,
  MonsterPower,
  MonsterPowerIntention,
} from "@/lib/summoning/types";

function clampEffectiveModifier(raw: number): number {
  return Math.max(-5, Math.min(5, raw));
}

export function formatModifierWithEffective(raw: number): string {
  const effective = clampEffectiveModifier(raw);
  const signedRaw = raw >= 0 ? `+${raw}` : `${raw}`;
  const signedEffective = effective >= 0 ? `+${effective}` : `${effective}`;

  if (raw === effective) return signedRaw;
  return `${signedRaw} (effective ${signedEffective})`;
}

export function effectiveCooldownTurns(power: Pick<MonsterPower, "cooldownTurns" | "cooldownReduction">): number {
  return Math.max(1, power.cooldownTurns - power.cooldownReduction);
}

function signedPotency(potency: number): string {
  return potency >= 0 ? `+${potency}` : `${potency}`;
}

function renderIntentionDetail(
  intention: MonsterPowerIntention,
  potency: number,
): string {
  const details = intention.detailsJson ?? {};

  switch (intention.type) {
    case "ATTACK":
      return `inflict ${potency * 2} wounds`;
    case "HEALING":
      return `restore ${potency} wound${potency === 1 ? "" : "s"}`;
    case "DEFENCE":
      return `block ${potency} wound${potency === 1 ? "" : "s"}`;
    case "AUGMENT": {
      const stat = String(details.statChoice ?? "Stat");
      return `gain 1 stack of ${signedPotency(potency)} ${stat}`;
    }
    case "DEBUFF": {
      const stat = String(details.statChoice ?? "Stat");
      return `apply 1 stack of -${potency} ${stat}`;
    }
    case "CONTROL": {
      const mode = String(details.controlMode ?? "APPLY_PRESSURE");
      if (mode === "REMOVE_PROGRESS") {
        return `remove ${potency} successes from the targeted effect`;
      }
      const controlEffect = String(details.controlEffect ?? "Control Effect");
      return `apply ${potency} stacks of ${controlEffect}`;
    }
    case "CLEANSE": {
      const effectType = String(details.cleanseEffectType ?? "selected effect type");
      return `remove ${potency} from ${effectType}`;
    }
    case "MOVEMENT":
      return `move the target ${potency * 5} feet`;
    case "SUMMON":
      return "resolve summon effect (V2 tooling)";
    case "TRANSFORMATION":
      return "resolve transformation effect (V2 tooling)";
    default:
      return "resolve effect";
  }
}

export function renderPowerSuccessClause(power: Pick<MonsterPower, "potency" | "intentions">): string {
  const sorted = [...power.intentions].sort((a, b) => a.sortOrder - b.sortOrder);
  const details = sorted.map((i) => renderIntentionDetail(i, power.potency));
  const joined =
    details.length <= 1
      ? details[0] ?? "resolve effect"
      : `${details.slice(0, -1).join("; ")}; and ${details[details.length - 1]}`;
  return `For each success, ${joined}.`;
}

export function renderPowerDurationText(
  power: Pick<MonsterPower, "durationType" | "durationTurns">,
): string | null {
  if (power.durationType === "INSTANT") return null;
  if (power.durationType === "TURNS") {
    return `Repeat this effect at the start of the target's turn until the target completes ${power.durationTurns} turn(s).`;
  }
  return "Repeat this effect at the start of the target's turn until removed.";
}

export function renderPowerStackCleanupText(
  power: Pick<MonsterPower, "durationType">,
): string | null {
  if (power.durationType === "INSTANT") return null;
  return "When this duration ends, remove all stacks generated by this Power.";
}

export function renderAttackActionLines(
  attackConfig: MonsterNaturalAttackConfig,
  weaponSkillValue: number,
  options?: { applyWeaponSkillOverride?: boolean },
): string[] {
  const descriptorInput = {
    itemType: "WEAPON",
    melee: attackConfig.melee
      ? {
          enabled: attackConfig.melee.enabled,
          damageTypes: attackConfig.melee.damageTypes as unknown as string[],
          targets: attackConfig.melee.targets,
          physicalStrength: attackConfig.melee.physicalStrength,
          mentalStrength: attackConfig.melee.mentalStrength,
          gsAttackEffects: attackConfig.melee.attackEffects,
        }
      : undefined,
    ranged: attackConfig.ranged
      ? {
          enabled: attackConfig.ranged.enabled,
          damageTypes: attackConfig.ranged.damageTypes as unknown as string[],
          targets: attackConfig.ranged.targets,
          distance: attackConfig.ranged.distance,
          physicalStrength: attackConfig.ranged.physicalStrength,
          mentalStrength: attackConfig.ranged.mentalStrength,
          gsAttackEffects: attackConfig.ranged.attackEffects,
        }
      : undefined,
    aoe: attackConfig.aoe
      ? {
          enabled: attackConfig.aoe.enabled,
          damageTypes: attackConfig.aoe.damageTypes as unknown as string[],
          count: attackConfig.aoe.count,
          centerRange: attackConfig.aoe.centerRange,
          shape: attackConfig.aoe.shape,
          geometry: {
            radius: attackConfig.aoe.sphereRadiusFeet ?? undefined,
            length:
              attackConfig.aoe.shape === "CONE"
                ? attackConfig.aoe.coneLengthFeet ?? undefined
                : attackConfig.aoe.lineLengthFeet ?? undefined,
            width: attackConfig.aoe.lineWidthFeet ?? undefined,
          },
          physicalStrength: attackConfig.aoe.physicalStrength,
          mentalStrength: attackConfig.aoe.mentalStrength,
          gsAttackEffects: attackConfig.aoe.attackEffects,
        }
      : undefined,
  };

  const descriptor = buildDescriptorResult(
    descriptorInput as unknown as Parameters<typeof buildDescriptorResult>[0],
  );

  const sections = renderForgeResult(
    descriptor,
    options?.applyWeaponSkillOverride ? { weaponSkillDiceOverride: weaponSkillValue } : undefined,
  );
  const attack = sections.find((s) => s.title === "Attack Actions");
  if (!attack) return [];

  return attack.lines;
}
